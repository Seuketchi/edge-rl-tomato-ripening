"""Convert a binary model file to a C header array for firmware embedding.

Produces a .h file with:
    extern const uint8_t <name>_data[];
    extern const uint32_t <name>_size;

Usage:
    python -m ml_training.bin_to_c_array \\
        --input  outputs/vision_*/tomato_classifier.onnx \\
        --name   vision_model \\
        --output edge_firmware/main/model_data.h

    python -m ml_training.bin_to_c_array \\
        --input  outputs/distill_*/rl_policy.onnx \\
        --name   rl_policy \\
        --output edge_firmware/main/policy_data.h
"""

from __future__ import annotations

import argparse
import textwrap
from pathlib import Path


def to_c_array(data: bytes, name: str) -> str:
    """Format raw bytes as a C uint8_t array literal.

    Args:
        data: Raw binary content.
        name: C identifier prefix (e.g. 'vision_model').

    Returns:
        Complete C header file as a string.
    """
    size = len(data)

    # Format bytes as hex, 16 per line
    hex_bytes = [f"0x{b:02X}" for b in data]
    lines = [", ".join(hex_bytes[i:i+16]) for i in range(0, len(hex_bytes), 16)]
    array_body = ",\n    ".join(lines)

    return textwrap.dedent(f"""\
        /* Auto-generated by ml_training/bin_to_c_array.py — do not edit manually.
         * Source: {name}
         * Size:   {size:,} bytes ({size / 1024:.1f} KB)
         */
        #pragma once
        #include <stdint.h>

        /* Model data — embedded in flash */
        const uint8_t {name}_data[] = {{
            {array_body}
        }};

        const uint32_t {name}_size = {size}U;
        """)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Binary model → C header array")
    parser.add_argument("--input",  required=True, help="Input binary file (.onnx or .espdl)")
    parser.add_argument("--name",   required=True, help="C identifier prefix (e.g. vision_model)")
    parser.add_argument("--output", required=True, help="Output .h file path")
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    input_path  = Path(args.input)
    output_path = Path(args.output)

    if not input_path.exists():
        raise FileNotFoundError(f"Input file not found: {input_path}")

    output_path.parent.mkdir(parents=True, exist_ok=True)

    print(f"Reading {input_path} ({input_path.stat().st_size / 1024:.1f} KB)...")
    data = input_path.read_bytes()

    print(f"Generating C array '{args.name}_data[]'...")
    c_code = to_c_array(data, args.name)

    output_path.write_text(c_code)
    print(f"✓ Written to {output_path}")
    print(f"  Array size: {len(data):,} bytes  ({len(data)/1024:.1f} KB)")
    print(f"\nIn firmware, include with:")
    print(f'  #include "{output_path.name}"')
    print(f"  // then pass {args.name}_data and {args.name}_size to ESP-DL loader")


if __name__ == "__main__":
    main()
